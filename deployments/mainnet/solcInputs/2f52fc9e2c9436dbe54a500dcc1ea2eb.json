{
  "language": "Solidity",
  "sources": {
    "contracts/governance/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IUniswapV2Pair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/v3/VaultHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILiquidityGaugeV2.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n/**\n * @title VaultHelper\n * @notice The VaultHelper acts as a single contract that users may set\n * token approvals on for any token of any vault.\n * @dev This contract has no state and could be deployed by anyone if\n * they didn't trust the original deployer.\n */\ncontract VaultHelper {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Deposits into the specified payable vault and stakes in the gauge if desired\n     * @param _vault The address of the vault\n     * @param _auto To automatically stake into the gauge\n     */\n    function depositVaultPayable(\n        address _vault,\n        bool _auto\n    )\n        external payable\n    {\n        uint256 _amount = msg.value;\n        require(msg.value > 0, \"!_amount\");\n        address _token = IVault(_vault).getToken();\n        address _vaultToken = IVault(_vault).getLPToken();\n        IWETH(_token).deposit{value: _amount}();\n        IERC20(_token).safeApprove(_vault, 0);\n        IERC20(_token).safeApprove(_vault, _amount);\n        uint256 _shares = IVault(_vault).deposit(_amount);\n        address _gauge = IVault(_vault).gauge();\n        if (_auto && _gauge != address(0)) {\n            IERC20(_vaultToken).safeApprove(_gauge, 0);\n            IERC20(_vaultToken).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);            \n        } else {\n            IERC20(_vaultToken).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits into the specified vault and stakes in the gauge\n     * @dev Users must approve the vault helper to spend their token\n     * @param _vault The address of the vault\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositVault(\n        address _vault,\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        address _token = IVault(_vault).getToken();\n        address _vaultToken = IVault(_vault).getLPToken();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_token).safeApprove(_vault, 0);\n        IERC20(_token).safeApprove(_vault, _amount);\n        uint256 _shares = IVault(_vault).deposit(_amount);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vaultToken).safeApprove(_gauge, 0);\n            IERC20(_vaultToken).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vaultToken).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    function withdrawVault(\n        address _vault,\n        uint256 _amount\n    )\n        external\n    {\n        address _gauge = IVault(_vault).gauge();\n        address _token = IVault(_vault).getToken();\n        address _vaultToken = IVault(_vault).getLPToken();\n        if (_gauge != address(0)) {\n            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);\n            ILiquidityGaugeV2(_gauge).withdraw(_amount);\n            IVault(_vault).withdraw(IERC20(_vaultToken).balanceOf(address(this)));\n            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        } else {\n            IERC20(_vaultToken).safeTransferFrom(msg.sender, address(this), _amount);\n            IVault(_vault).withdraw(_amount);\n            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/v3/interfaces/ILiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ILiquidityGaugeV2 {\n    function set_approve_deposit(address, bool) external;\n    function deposit(uint256) external;\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/v3/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IVault {\n    function available() external view returns (uint256);\n    function balance() external view returns (uint256);\n    function deposit(uint256 _amount) external returns (uint256);\n    function earn(address _strategy) external;\n    function gauge() external returns (address);\n    function getLPToken() external view returns (address);\n    function getPricePerFullShare() external view returns (uint256);\n    function getToken() external view returns (address);\n    function manager() external view returns (IManager);\n    function withdraw(uint256 _amount) external;\n    function withdrawAll() external;\n    function withdrawFee(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/v3/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/v3/interfaces/IManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IManager {\n    function addVault(address) external;\n    function allowedControllers(address) external view returns (bool);\n    function allowedConverters(address) external view returns (bool);\n    function allowedStrategies(address) external view returns (bool);\n    function allowedVaults(address) external view returns (bool);\n    function controllers(address) external view returns (address);\n    function getHarvestFeeInfo() external view returns (address, address, uint256);\n    function getToken(address) external view returns (address);\n    function governance() external view returns (address);\n    function halted() external view returns (bool);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function pendingStrategist() external view returns (address);\n    function removeVault(address) external;\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryFee() external view returns (uint256);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yaxis() external view returns (address);\n}\n"
    },
    "contracts/v3/strategies/TRICRYPTO2ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPool.sol';\nimport '../interfaces/IStableSwap3Pool.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\nimport '../interfaces/IWETH.sol';\n\ncontract TRICRYPTO2ConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n\n    address[] public tokens;\n    uint8[] public decimalMultiples;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _coinCount The number of coins in the pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        uint256 _pid,\n        uint256 _coinCount,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [1] should be set to Uniswap router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IStableSwapPool(_stableSwapPool).coins(i));\n            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());\n            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);\n        }\n\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        _setApprovals(_crvethPool, _cvxethPool, _routerArray, _crvRewards);\n    }\n\n    function _setApprovals(\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress[] memory _routerArray,\n    \taddress _crvRewards\n    ) internal {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n    \tuint _routerArrayLength = _routerArray.length;\n\t    uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, 0);\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\n    \t}\n    }\n    \n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) public payable onlyController {\n        uint256[3] memory amounts;\n        amounts[2] = address(this).balance;\n        IStableSwap3Pool(stableSwapPool).add_liquidity{value: amounts[2]}(amounts, _estimate);\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            IWETH(weth).withdraw(_remainingWeth);\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/v3/interfaces/IConvexVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IConvexVault {\n    function poolInfo(uint256 pid)\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function deposit(\n        uint256 pid,\n        uint256 amount,\n        bool stake\n    ) external returns (bool);\n\n    function depositAll(uint256 pid, bool stake) external returns (bool);\n\n    function withdraw(uint256 pid, uint256 amount) external returns (bool);\n\n    function withdrawAll(uint256 pid) external returns (bool);\n}\n\ninterface IConvexRewards {\n    function getReward(address _account, bool _claimExtras) external returns (bool);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256 _pid) external view returns (address);\n\n    function rewardToken() external view returns (address);\n\n    function earned(address _account) external view returns (uint256);\n\n    function withdrawAllAndUnwrap(bool claim) external;\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns(bool);\n}\n"
    },
    "contracts/v3/interfaces/ExtendedIERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface ExtendedIERC20 {\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/v3/interfaces/IStableSwapPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwapPool {\n    function coins(uint256) external view returns (address);\n    function get_virtual_price() external view returns (uint);\n    function price_oracle(uint256) external view returns (uint256);\n}\n"
    },
    "contracts/v3/interfaces/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function coins(uint) external view returns (address);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external payable;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/v3/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IStableSwap3Pool.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IController.sol\";\n\n/**\n * @title BaseStrategy\n * @notice The BaseStrategy is an abstract contract which all\n * yAxis strategies should inherit functionality from. It gives\n * specific security properties which make it hard to write an\n * insecure strategy.\n * @notice All state-changing functions implemented in the strategy\n * should be internal, since any public or externally-facing functions\n * are already handled in the BaseStrategy.\n * @notice The following functions must be implemented by a strategy:\n * - function _deposit() internal virtual;\n * - function _harvest() internal virtual;\n * - function _withdraw(uint256 _amount) internal virtual;\n * - function _withdrawAll() internal virtual;\n * - function balanceOfPool() public view override virtual returns (uint256);\n */\nabstract contract BaseStrategy is IStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    address public immutable override want;\n    address public immutable override weth;\n    address public immutable controller;\n    IManager public immutable override manager;\n    string public override name;\n    address[] public routerArray;\n    ISwap public override router;\n\n    /**\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _want The desired token of the strategy\n     * @param _weth The address of WETH\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _controller,\n        address _manager,\n        address _want,\n        address _weth,\n        address[] memory _routerArray\n    ) public {\n        name = _name;\n        want = _want;\n        controller = _controller;\n        manager = IManager(_manager);\n        weth = _weth;\n        require(_routerArray.length > 0, \"Must input at least one router\");\n        routerArray = _routerArray;\n        router = ISwap(_routerArray[0]);\n        for(uint i = 0; i < _routerArray.length; i++) {\n            IERC20(_weth).safeApprove(address(_routerArray[i]), 0);\n            IERC20(_weth).safeApprove(address(_routerArray[i]), type(uint256).max);\n        }\n        \n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Approves a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Sets the address of the ISwap-compatible router\n     * @param _routerArray The addresses of routers\n     * @param _tokenArray The addresses of tokens that need to be approved by the strategy\n     */\n     function setRouter(\n        address[] calldata _routerArray,\n        address[] calldata _tokenArray\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        routerArray = _routerArray;\n        router = ISwap(_routerArray[0]);\n        address _router;\n        uint256 _routerLength = _routerArray.length;\n        uint256 _tokenArrayLength = _tokenArray.length;\n        for(uint i = 0; i < _routerLength; i++) {\n            _router = _routerArray[i];\n            IERC20(weth).safeApprove(_router, 0);\n            IERC20(weth).safeApprove(_router, type(uint256).max);\n            for(uint j = 0; j < _tokenArrayLength; j++) {\n                IERC20(_tokenArray[j]).safeApprove(_router, 0);\n                IERC20(_tokenArray[j]).safeApprove(_router, type(uint256).max);\n            }\n        }\n\n    }\n    \n    /**\n     * @notice Sets the default ISwap-compatible router\n     * @param _routerIndex Gets the address of the router from routerArray\n     */\n     function setDefaultRouter(\n        uint256 _routerIndex\n    )\n        external\n    {\n    \trequire(msg.sender == manager.governance(), \"!governance\");\n    \trouter = ISwap(routerArray[_routerIndex]);\n    }\n\n    /**\n     * CONTROLLER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits funds to the strategy's pool\n     */\n    function deposit()\n        external\n        override\n        onlyController\n    {\n        _deposit();\n    }\n\n    /**\n     * @notice Harvest funds in the strategy's pool\n     */\n    function harvest(\n        uint256[] calldata _estimates\n    )\n        external\n        override\n        onlyController\n    {\n        _harvest(_estimates);\n    }\n\n    /**\n     * @notice Sends stuck want tokens in the strategy to the controller\n     */\n    function skim()\n        external\n        override\n        onlyController\n    {\n        IERC20(want).safeTransfer(controller, balanceOfWant());\n    }\n\n    /**\n     * @notice Sends stuck tokens in the strategy to the controller\n     * @param _asset The address of the token to withdraw\n     */\n    function withdraw(\n        address _asset\n    )\n        external\n        override\n        onlyController\n    {\n        require(want != _asset, \"want\");\n\n        IERC20 _assetToken = IERC20(_asset);\n        uint256 _balance = _assetToken.balanceOf(address(this));\n        _assetToken.safeTransfer(controller, _balance);\n    }\n\n    /**\n     * @notice Initiated from a vault, withdraws funds from the pool\n     * @param _amount The amount of the want token to withdraw\n     */\n    function withdraw(\n        uint256 _amount\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 _balance = balanceOfWant();\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        IERC20(want).safeTransfer(controller, _amount);\n    }\n\n    /**\n     * @notice Withdraws all funds from the strategy\n     */\n    function withdrawAll()\n        external\n        override\n        onlyController\n    {\n        _withdrawAll();\n\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n\n        IERC20(want).safeTransfer(controller, _balance);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the strategy's balance of the want token plus the balance of pool\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the pool\n     * @dev Must be implemented by the strategy\n     */\n    function balanceOfPool()\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    /**\n     * @notice Returns the balance of the want token on the strategy\n     */\n    function balanceOfWant()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    function _deposit()\n        internal\n        virtual;\n\n    function _harvest(\n        uint256[] calldata _estimates\n    )\n        internal\n        virtual;\n\n    function _payHarvestFees()\n        internal\n        returns (uint256 _wethBal)\n    {\n        _wethBal = IERC20(weth).balanceOf(address(this));\n        if (_wethBal > 0) {\n            // get all the necessary variables in a single call\n            (\n                ,\n                address treasury,\n                uint256 treasuryFee\n            ) = manager.getHarvestFeeInfo();\n            uint256 _fee;\n            // pay the treasury with YAX\n            if (treasuryFee > 0 && treasury != address(0)) {\n                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);\n\n                IERC20(weth).safeTransfer(treasury, _fee);\n            }\n            // return the remaining WETH balance\n            _wethBal = IERC20(weth).balanceOf(address(this));\n        }\n    }\n\n    function _swapTokensWithRouterIndex(\n        address _input,\n        address _output,\n        uint256 _amount,\n        uint256 _expected,\n        uint256 _routerIndex\n    )\n        internal\n    {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        ISwap(routerArray[_routerIndex]).swapExactTokensForTokens(\n            _amount,\n            _expected,\n            path,\n            address(this),\n            // The deadline is a hardcoded value that is far in the future.\n            1e10\n        );\n    }\n    \n    function _swapTokens(\n        address _input,\n        address _output,\n        uint256 _amount,\n        uint256 _expected\n    )\n        internal\n    {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        router.swapExactTokensForTokens(\n            _amount,\n            _expected,\n            path,\n            address(this),\n            // The deadline is a hardcoded value that is far in the future.\n            1e10\n        );\n    }\n\n    function _swapTokensCurve(\n        address _pool,\n        uint256 _i,\n        uint256 _j,\n        uint256 _dx,\n        uint256 _min_dy\n    )\n        internal\n    {\n        ICurvePool(_pool).exchange(\n            _i,\n            _j,\n            _dx,\n            _min_dy\n        );\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        virtual;\n\n    function _withdrawAll()\n        internal\n        virtual;\n\n    function _withdrawSome(\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 _before = IERC20(want).balanceOf(address(this));\n        _withdraw(_amount);\n        uint256 _after = IERC20(want).balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"!controller\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ICVXMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ICVXMinter {\n    function maxSupply() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function totalCliffs() external view returns (uint256);\n    function reductionPerCliff() external view returns (uint256);\n}\n"
    },
    "contracts/v3/interfaces/IHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IHarvester {\n    function addStrategy(address, address, uint256) external;\n    function manager() external view returns (IManager);\n    function removeStrategy(address, address, uint256) external;\n    function slippage() external view returns (uint256);\n}\n\n"
    },
    "contracts/v3/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function coins(uint256) external view returns (address);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface ISwap {\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;\n    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/v3/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\nimport \"./ISwap.sol\";\n\ninterface IStrategy {\n    function balanceOf() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function deposit() external;\n    function harvest(uint256[] calldata) external;\n    function manager() external view returns (IManager);\n    function name() external view returns (string memory);\n    function router() external view returns (ISwap);\n    function skim() external;\n    function want() external view returns (address);\n    function weth() external view returns (address);\n    function withdraw(address) external;\n    function withdraw(uint256) external;\n    function withdrawAll() external;\n}\n\ninterface IStrategyExtended {\n    function getEstimates() external view returns (uint256[] memory);\n}\n"
    },
    "contracts/v3/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IController {\n    function balanceOf() external view returns (uint256);\n    function converter(address _vault) external view returns (address);\n    function earn(address _strategy, address _token, uint256 _amount) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address _strategy, uint256[] calldata _estimates) external;\n    function manager() external view returns (IManager);\n    function strategies() external view returns (uint256);\n    function withdraw(address _token, uint256 _amount) external;\n    function withdrawAll(address _strategy, address _convert) external;\n}\n"
    },
    "contracts/v3/strategies/NativeStrategyCurve3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\nimport '../interfaces/IHarvester.sol';\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    address public immutable crvethPool;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _crvethPool,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        crvethPool = _crvethPool;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_crv).safeApprove(_crvethPool, type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity(uint256 _estimate)\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, _estimate);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256[] calldata _estimates\n    )\n        internal\n        override\n    {\n        _claimReward();\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity(_estimates[0]);\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Gauge {\n    function deposit(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function withdraw(uint) external;\n    function claimable_tokens(address) external view returns (uint);\n}\n\ninterface Mintr {\n    function mint(address) external;\n}\n"
    },
    "contracts/interfaces/Balancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Balancer {\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint poolAmountIn,\n        uint minAmountOut\n    ) external returns (uint tokenAmountOut);\n}\n"
    },
    "contracts/v3/strategies/MIMConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ICurvePool.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport '../interfaces/IStableSwap3Pool.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\n\ncontract MIMConvexStrategy is BaseStrategy {\n    // used for Crv -> weth -> [mim/3crv] -> mimCrv route\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    address public immutable mim;\n    address public immutable crv3;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    IStableSwap2Pool public immutable stableSwap2Pool;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _mim The address of MIM\n     * @param _crv3 The address of 3CRV\n     * @param _stableSwap3Pool The address of the 3CRV pool\n     * @param _pid The pool id of convex\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwap2Pool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The address array of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        address _mim,\n        address _crv3,\n        IStableSwap3Pool _stableSwap3Pool,\n        uint256 _pid,\n        IConvexVault _convexVault,\n        IStableSwap2Pool _stableSwap2Pool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(address(_mim) != address(0), '!_mim');\n        require(address(_crv3) != address(0), '!_crv3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwap2Pool) != address(0), '!_stableSwap2Pool');\n        require(address(_stableSwap3Pool) != address(0), '!_stableSwap3Pool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        mim = _mim;\n        crv3 = _crv3;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwap2Pool = _stableSwap2Pool;\n        stableSwap3Pool = _stableSwap3Pool;\n        // Required to overcome \"Stack Too Deep\" error\n        _setApprovals(\n            _want,\n            _crvethPool,\n            _cvxethPool,\n            _mim,\n            _crv3,\n            address(_convexVault),\n            address(_stableSwap2Pool)\n        );\n        _setMoreApprovals(address(_stableSwap3Pool), _crvRewards, _routerArray);\n    }\n    \n    function _setMoreApprovals(address _stableSwap3Pool, address _crvRewards, address[] memory _routerArray) internal {\n        IERC20(IStableSwap3Pool(_stableSwap3Pool).coins(0)).safeApprove(_stableSwap3Pool, type(uint256).max);\n        IERC20(IStableSwap3Pool(_stableSwap3Pool).coins(1)).safeApprove(_stableSwap3Pool, type(uint256).max);\n        IERC20(IStableSwap3Pool(_stableSwap3Pool).coins(2)).safeApprove(_stableSwap3Pool, type(uint256).max);   \n        uint _routerArrayLength = _routerArray.length;\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n            if (rewardsLength > 0) {\n                for(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n                }\n            }\n        }\t \t\n    }\n\n    function _setApprovals(\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _mim,\n        address _crv3,\n        address _convexVault,\n        address _stableSwap2Pool\n    ) internal {\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n        IERC20(_mim).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n        IERC20(_crv3).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        if (balanceOfWant() > 0) {\n            convexVault.depositAll(pid, true);\n        }\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 estimate) internal {\n        uint256[2] memory amounts;\n        amounts[1] = IERC20(crv3).balanceOf(address(this));\n        stableSwap2Pool.add_liquidity(amounts, estimate);\n    }\n\n    function _addLiquidity3CRV(uint256 estimate) internal {\n        uint256[3] memory amounts;\n        (address targetCoin, uint256 targetIndex) = getMostPremium();\n        amounts[targetIndex] = IERC20(targetCoin).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, estimate);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256 daiBalance = stableSwap3Pool.balances(0);\n        uint256 usdcBalance = (stableSwap3Pool.balances(1)).mul(10**18).div(ExtendedIERC20(stableSwap3Pool.coins(1)).decimals());\n        uint256 usdtBalance = (stableSwap3Pool.balances(2)).mul(10**12); \n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (stableSwap3Pool.coins(0), 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (stableSwap3Pool.coins(1), 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (stableSwap3Pool.coins(2), 2);\n        }\n\n        return (stableSwap3Pool.coins(0), 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            (address _token, ) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _token, _remainingWeth, 1);\n            _addLiquidity3CRV(0);\n            _addLiquidity(_estimates[0]);\n            _deposit();\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/interfaces/IStableSwap2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap2Pool {\n    function get_virtual_price() external view returns (uint256);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/strategies/GeneralConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPool.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\ncontract GeneralConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n\n    address[] public tokens;\n    address public premiumToken;\n    uint8[] public decimalMultiples;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _coinCount The number of coins in the pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _premiumTokenIndex The index of the premium asset in the liquidity pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        uint256 _pid,\n        uint256 _coinCount,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        uint256 _premiumTokenIndex,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [1] should be set to Uniswap router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IStableSwapPool(_stableSwapPool).coins(i));\n            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());\n            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);\n        }\n        premiumToken = IStableSwapPool(_stableSwapPool).coins(_premiumTokenIndex);\n\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        _setApprovals(_crvethPool, _cvxethPool, _routerArray, _crvRewards);\n    }\n\n    function _setApprovals(\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress[] memory _routerArray,\n    \taddress _crvRewards\n    ) internal {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n    \tuint _routerArrayLength = _routerArray.length;\n\t    uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\n    \t}\n    }\n    \n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) internal {\n        if (tokens.length == 2) {\n            uint256[2] memory amounts;\n            amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n            amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n            IStableSwap2Pool(stableSwapPool).add_liquidity(amounts, _estimate);\n            return;\n        }\n\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n        amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n        amounts[2] = IERC20(tokens[2]).balanceOf(address(this));\n        IStableSwap3Pool(stableSwapPool).add_liquidity(amounts, _estimate);\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, premiumToken, _remainingWeth, 1);\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/strategies/ETHConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport '../interfaces/IWETH.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\n\ncontract ETHConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable aleth;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    IStableSwap2Pool public immutable stableSwapPool;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _aleth The address of alternative ETH\n     * @param _pid The pool id of convex\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        address _aleth,\n        uint256 _pid,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(address(_aleth) != address(0), '!_aleth');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        aleth = _aleth;\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = IStableSwap2Pool(_stableSwapPool);\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n        \n        _setApprovals(\n            _crvethPool,\n            _cvxethPool,\n        \t_want,\n        \taddress(_convexVault),\n        \t_stableSwapPool,\n        \t_aleth,\n        \t_routerArray,\n\t\t    _crvRewards\n        );\n    }\n    \n    function _setApprovals(\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress _want,\n    \taddress _convexVault,\n    \taddress _stableSwapPool,\n    \taddress _aleth,\n    \taddress[] memory _routerArray,\n\t    address _crvRewards\n    )\n        internal\n    {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        uint256 _routerArrayLength = _routerArray.length;\n        uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, 0);\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\t    \n        }\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        IERC20(_aleth).safeApprove(_stableSwapPool, type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) public payable onlyController {\n        uint256[2] memory amounts;\n        amounts[0] = address(this).balance;\n        stableSwapPool.add_liquidity{value: amounts[0]}(amounts, _estimate);\n        return;\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            IWETH(weth).withdraw(_remainingWeth);\n        }\n        _addLiquidity(_estimates[0]);\n        if (balanceOfWant() > 0) {\n            _deposit();\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/v3/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IVaultToken.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n    IERC20 public immutable token;\n    IVaultToken public immutable vaultToken;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _depositToken The address of the deposit token of the vault\n     * @param _vaultToken The address of the share token for the vault\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        address _depositToken,\n        address _vaultToken,\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        token = IERC20(_depositToken);\n        vaultToken = IVaultToken(_vaultToken);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _strategy\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available();\n            token.safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, address(token), _balance);\n            emit Earn(address(token), _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        uint256 _amount\n     )\n        public\n        override\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = token.balanceOf(address(this)).sub(_before);\n        uint256 _supply = IERC20(address(vaultToken)).totalSupply();\n\n        _amount = _normalizeDecimals(_amount);\n\n        if (_supply > 0) {\n            _amount = (_amount.mul(_supply)).div(_balance);\n        }\n\n        _shares = _amount;\n\n        require(_shares > 0, \"shares=0\");\n        require(_supply.add(_shares) <= totalDepositCap, \">totalDepositCap\");\n        vaultToken.mint(msg.sender, _shares);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     */\n    function withdraw(\n        uint256 _shares\n    )\n        public\n        override\n    {\n        uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply());\n        vaultToken.burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = token.balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(address(token), _toWithdraw);\n            }\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        token.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     */\n    function withdrawAll()\n        external\n        override\n    {\n        withdraw(IERC20(address(vaultToken)).balanceOf(msg.sender));\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     */\n    function available()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return token.balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(_normalizeDecimals(IController(manager.controllers(address(this))).balanceOf()));\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256)\n    {\n        return _normalizeDecimals(token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _supply = IERC20(address(vaultToken)).totalSupply();\n        if (_supply > 0) {\n            return balance().mul(1e18).div(_supply);\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns the deposit token for the vault\n     */\n    function getToken()\n        public\n        view\n        override\n        returns (address)\n    {\n        return address(token);\n    }\n\n    function getLPToken()\n        external\n        view\n        override\n        returns (address)\n    {\n        return address(vaultToken);\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(address(token)).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "contracts/v3/interfaces/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IConverter {\n    function manager() external view returns (IManager);\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    ) external returns (uint256 _outputAmount);\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external view returns (uint256 _outputAmount);\n}\n"
    },
    "contracts/v3/interfaces/IVaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVaultToken {\n    function mint(address,uint256) external;\n    function burn(address,uint256) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/v3/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IVaultToken.sol\";\n\n/**\n * @notice Vault Token\n * @dev Contract has been copied from:\n * with modification made to specify name and symbol, deploys with 0 total supply\n */\ncontract VaultToken is IVaultToken, ERC20 {\n\n    IManager public immutable manager;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        ERC20(_name, _symbol)\n    // solhint-disable-next-line no-empty-blocks\n    {\n        manager = IManager(_manager);\n    }\n\n    function mint(\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault\n    {\n        _mint(_account, _amount);\n    }\n\n    function burn(\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault\n    {\n        _burn(_account, _amount);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(recipient)\n    {\n        super._transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(spender)\n    {\n        super._approve(owner, spender, amount);\n    }\n\n\n    // MODIFIERS\n\n    modifier validAddress(address _recipient) {\n        require(_recipient != address(this), \"!validAddress\");\n        _;\n    }\n\n    modifier onlyVault() {\n        require(manager.allowedVaults(msg.sender), \"!vault\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/v3/Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => token\n    mapping(address => address) internal tokens;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event VaultAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event VaultRemoved(\n        address indexed _vault\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 5000, \"_treasuryFee over 50%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     */\n    function addVault(\n        address _vault\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault] == address(0), \"!_vault\");\n        address _token = IVault(_vault).getToken();\n        tokens[_vault] = _token;\n        emit VaultAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     */\n    function removeVault(\n        address _vault\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(tokens[_vault] != address(0), \"!_vault\");\n        delete tokens[_vault];\n        delete allowedVaults[_vault];\n        emit VaultRemoved(_vault);\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getToken(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/Harvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/ISwap.sol\";\n\n/**\n * @title Harvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given vault. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract Harvester is IHarvester {\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    IManager public immutable override manager;\n    IController public immutable controller;\n\n    uint256 public override slippage;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @param _manager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(\n        address _manager,\n        address _controller\n    )\n        public\n    {\n        manager = IManager(_manager);\n        controller = IController(_controller);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        strategies[_vault].addresses.push(_strategy);\n        strategies[_vault].timeout = _timeout;\n        emit StrategyAdded(_vault, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 tail = strategies[_vault].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_vault].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];\n            strategies[_vault].addresses.pop();\n            strategies[_vault].timeout = _timeout;\n            emit StrategyRemoved(_vault, _strategy, _timeout);\n        }\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(\n        address _harvester,\n        bool _status\n    )\n        external\n        onlyStrategist\n    {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    function setSlippage(\n        uint256 _slippage\n    )\n        external\n        onlyStrategist\n    {\n        require(_slippage < ONE_HUNDRED_PERCENT, \"!_slippage\");\n        slippage = _slippage;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    function earn(\n        address _strategy,\n        address _vault\n    )\n        external\n        onlyHarvester\n    {\n        IVault(_vault).earn(_strategy);\n    }\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     * @param _estimates The estimated outputs from swaps during harvest\n     */\n    function harvest(\n        IController _controller,\n        address _strategy,\n        uint256[] calldata _estimates\n    )\n        public\n        onlyHarvester\n    {\n        _controller.harvestStrategy(_strategy, _estimates);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given vault and\n     * rotates the strategies\n     * @param _vault The address of the vault\n     * @param _estimates The estimated outputs from swaps during harvest\n     */\n    function harvestNextStrategy(\n        address _vault,\n        uint256[] calldata _estimates\n    )\n        external\n    {\n        require(canHarvest(_vault), \"!canHarvest\");\n        address strategy = strategies[_vault].addresses[0];\n        harvest(controller, strategy, _estimates);\n        uint256 k = strategies[_vault].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_vault].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_vault].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_vault].lastCalled = block.timestamp;\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategyAddresses(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return strategies[_vault].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a vault's strategy to be harvested\n     * @param _vault The address of the vault\n     */\n    function canHarvest(\n        address _vault\n    )\n        public\n        view\n        returns (bool)\n    {\n        Strategy storage strategy = strategies[_vault];\n        // only can harvest if there are strategies, and when sufficient time has elapsed\n        // solhint-disable-next-line not-rely-on-time\n        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyController() {\n        require(manager.allowedControllers(msg.sender), \"!controller\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/controllers/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        if(IStrategy(_strategy).want() != IVault(_vault).getToken()) {\n            require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        }\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        require(_strategy == vaultDetail.strategies[index], \"Strategy not added\");\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256[] calldata _estimates\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimates);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault()\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault()\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(msg.sender, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _vault The address of the vault\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _vault,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault() {\n        require(manager.allowedVaults(msg.sender), \"!vault\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/converters/StablesConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/ICurve3Pool.sol\";\n\n/**\n * @title StablesConverter\n */\ncontract StablesConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IManager public immutable override manager;\n    ICurve3Pool public immutable stableSwap3Pool;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    IERC20[3] public tokens; // DAI, USDC, USDT\n\n    mapping(address => int128) internal indices;\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _stableSwap3Pool The address of 3Pool\n     * @param _manager The address of the Vault Manager\n     */\n    constructor(\n        IERC20 _tokenDAI,\n        IERC20 _tokenUSDC,\n        IERC20 _tokenUSDT,\n        IERC20 _token3CRV,\n        ICurve3Pool _stableSwap3Pool,\n        IManager _manager\n    ) public {\n        tokens[0] = _tokenDAI;\n        tokens[1] = _tokenUSDC;\n        tokens[2] = _tokenUSDT;\n        indices[address(_tokenDAI)] = 0;\n        indices[address(_tokenUSDC)] = 1;\n        indices[address(_tokenUSDT)] = 2;\n        token3CRV = _token3CRV;\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        manager = _manager;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Called by the strategist to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Allows the strategist to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function recoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     * @param _estimatedOutput The estimated output tokens after converting\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    )\n        external\n        override\n        onlyAuthorized\n        returns (uint256 _outputAmount)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    uint256 _before = token3CRV.balanceOf(address(this));\n                    stableSwap3Pool.add_liquidity(amounts, _estimatedOutput);\n                    uint256 _after = token3CRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    token3CRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            // A temporary cache, used to save gas.\n            IERC20 _token;\n            for (uint8 i = 0; i < 3; i++) {\n                _token = tokens[i];\n                if (_output == address(_token)) {\n                    uint256 _before = _token.balanceOf(address(this));\n                    stableSwap3Pool.remove_liquidity_one_coin(\n                        _inputAmount,\n                        i,\n                        _estimatedOutput\n                    );\n                    uint256 _after = _token.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    _token.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else {\n            stableSwap3Pool.exchange(\n                indices[_input],\n                indices[_output],\n                _inputAmount,\n                _estimatedOutput\n            );\n            _outputAmount = IERC20(_output).balanceOf(address(this));\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n            return _outputAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    )\n        external\n        override\n        view\n        returns (uint256)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    return stableSwap3Pool.calc_token_amount(amounts, true);\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        } else {\n            return stableSwap3Pool.get_dy(indices[_input], indices[_output], _inputAmount);\n        }\n        return 0;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @dev Throws if not called by an allowed vault, controller, or strategy\n     */\n    modifier onlyAuthorized() {\n        require(manager.allowedVaults(msg.sender)\n            || manager.allowedControllers(msg.sender)\n            || manager.allowedStrategies(msg.sender),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ICurve3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurve3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/v3/converters/GeneralConverter.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n// SPDX-License-Identifier: MIT\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport '../interfaces/IConverter.sol';\nimport '../interfaces/IManager.sol';\nimport '../interfaces/ICurvePool.sol';\nimport '../interfaces/ICurve2Pool.sol';\nimport '../interfaces/ICurve3Pool.sol';\n\n/**\n * @title GeneralConverter\n */\ncontract GeneralConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IManager public immutable override manager;\n    ICurvePool public immutable swapPool;\n    IERC20 public immutable tokenCRV;\n\n    IERC20[] public tokens;\n\n    mapping(address => int128) internal indices;\n\n    /**\n     * @param _coinCount The number of coins in the pool\n     * @param _tokenCRV The address of the CRV token\n     * @param _swapPool The address of swap pool\n     * @param _manager The address of the Vault Manager\n     */\n    constructor(\n        uint256 _coinCount,\n        IERC20 _tokenCRV,\n        ICurvePool _swapPool,\n        IManager _manager\n    ) public {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n\n        tokenCRV = _tokenCRV;\n        swapPool = _swapPool;\n        manager = _manager;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IERC20(_swapPool.coins(i)));\n            indices[address(tokens[i])] = int128(i);\n            tokens[i].safeApprove(address(_swapPool), type(uint256).max);\n        }\n\n        _tokenCRV.safeApprove(address(_swapPool), type(uint256).max);\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Called by the strategist to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyStrategist {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Allows the strategist to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function recoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyStrategist {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     * @param _estimatedOutput The estimated output tokens after converting\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    ) external override onlyAuthorized returns (uint256 _outputAmount) {\n        if (_output == address(tokenCRV)) {\n            // convert to CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_input == address(tokens[i])) {\n                    uint256 _before = tokenCRV.balanceOf(address(this));\n\n                    if (tokens.length == 2) {\n                        uint256[2] memory amounts;\n                        amounts[i] = _inputAmount;\n                        ICurve2Pool(address(swapPool)).add_liquidity(\n                            amounts,\n                            _estimatedOutput\n                        );\n                    } else {\n                        uint256[3] memory amounts;\n                        amounts[i] = _inputAmount;\n                        ICurve3Pool(address(swapPool)).add_liquidity(\n                            amounts,\n                            _estimatedOutput\n                        );\n                    }\n\n                    uint256 _after = tokenCRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    tokenCRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(tokenCRV)) {\n            // convert from CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_output == address(tokens[i])) {\n                    uint256 _before = tokens[i].balanceOf(address(this));\n                    swapPool.remove_liquidity_one_coin(_inputAmount, i, _estimatedOutput);\n                    uint256 _after = tokens[i].balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    tokens[i].safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else {\n            swapPool.exchange(\n                indices[_input],\n                indices[_output],\n                _inputAmount,\n                _estimatedOutput\n            );\n            _outputAmount = IERC20(_output).balanceOf(address(this));\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n            return _outputAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external view override returns (uint256) {\n        if (_output == address(tokenCRV)) {\n            // convert to CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_input == address(tokens[i])) {\n                    if (tokens.length == 2) {\n                        uint256[2] memory amounts;\n                        amounts[i] = _inputAmount;\n                        return ICurve2Pool(address(swapPool)).calc_token_amount(amounts, true);\n                    } else {\n                        uint256[3] memory amounts;\n                        amounts[i] = _inputAmount;\n                        return ICurve3Pool(address(swapPool)).calc_token_amount(amounts, true);\n                    }\n                }\n            }\n        } else if (_input == address(tokenCRV)) {\n            // convert from CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return swapPool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        } else {\n            return swapPool.get_dy(indices[_input], indices[_output], _inputAmount);\n        }\n        return 0;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @dev Throws if not called by an allowed vault, controller, or strategy\n     */\n    modifier onlyAuthorized() {\n        require(\n            manager.allowedVaults(msg.sender) ||\n                manager.allowedControllers(msg.sender) ||\n                manager.allowedStrategies(msg.sender),\n            '!authorized'\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), '!strategist');\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ICurve2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurve2Pool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/MinterWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MinterWrapper is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public immutable token;\n    address public minter;\n    uint256 public rate;\n\n    event Write();\n\n    constructor(\n        address _token\n    )\n        public\n        Ownable()\n    {\n        token = IERC20(_token);\n        rate = 1e12;\n    }\n\n    /**\n     * @notice Sets the address of the minter contract\n     * @dev can only be set once\n     * @param _minter The address of the minter\n     */\n    function setMinter(\n        address _minter\n    )\n        external\n        onlyOwner\n    {\n        require(minter == address(0), \"minter\");\n        require(_minter != address(0), \"!_minter\");\n        minter = _minter;\n    }\n\n    /**\n     * @notice Sets the emission rate\n     * @param _rate The rate of reward token emissions\n     */\n    function setRate(\n        uint256 _rate\n    )\n        external\n        onlyOwner\n    {\n        rate = _rate;\n    }\n\n    /**\n     * @notice Mints the given amount to the given account\n     * @dev Requires this contract to be funded with the reward token\n     * @param _account The address to receive the reward tokens\n     * @param _amount The amount of tokens to send the receiver\n     */\n    function mint(\n        address _account,\n        uint256 _amount\n    )\n        external\n        returns (bool)\n    {\n        require(msg.sender == minter, \"!minter\");\n        token.safeTransfer(_account, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Returns the current block timestamp\n     * @dev Emits Write event to prevent from being a view function\n     */\n    function future_epoch_time_write()\n        external\n        returns (uint256)\n    {\n        emit Write();\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Returns the amount of reward tokens on this contract\n     */\n    function available_supply()\n        public\n        view\n        returns (uint256)\n    {\n        return token.balanceOf(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/v3/strategies/FraxConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPoolFrax.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\ncontract FraxConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable usdc;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n    address public immutable fraxPool;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _usdc The address of USDC\n     * @param _fraxPool The address of FRAX pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        uint256 _pid,\n        address _usdc,\n        address _fraxPool,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [1] should be set to Uniswap router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        usdc = _usdc;\n        fraxPool = _fraxPool;\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n\n        IERC20(_usdc).safeApprove(_stableSwapPool, type(uint256).max);\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        _setApprovals(_crvethPool, _cvxethPool, _routerArray, _crvRewards);\n    }\n\n    function _setApprovals(\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress[] memory _routerArray,\n    \taddress _crvRewards\n    ) internal {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n    \tuint _routerArrayLength = _routerArray.length;\n\t    uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, 0);\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\n    \t}\n    }\n    \n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) internal {\n        uint256[4] memory amounts;\n        amounts[2] = IERC20(usdc).balanceOf(address(this));\n        IStableSwapPool(stableSwapPool).add_liquidity(fraxPool, amounts, _estimate);\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, usdc, _remainingWeth, 1);\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/interfaces/IStableSwapPoolFrax.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwapPool {\n    function add_liquidity(address pool, uint[4] calldata amounts, uint min_mint_amount) external;\n}\n"
    },
    "contracts/v3/strategies/CVXETHConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPool.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\ncontract CVXETHConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n\n    address[] public tokens;\n    uint8[] public decimalMultiples;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _coinCount The number of coins in the pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        uint256 _pid,\n        uint256 _coinCount,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [1] should be set to Uniswap router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IStableSwapPool(_stableSwapPool).coins(i));\n            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());\n            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);\n        }\n\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        _setApprovals(_crvethPool, _cvxethPool, _routerArray, _crvRewards);\n    }\n\n    function _setApprovals(\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress[] memory _routerArray,\n    \taddress _crvRewards\n    ) internal {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);      \n    \tuint _routerArrayLength = _routerArray.length;\n\t    uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, 0);\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\n    \t}\n    }\n    \n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) internal {      \n        uint256[2] memory amounts;\n        amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n        amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n        IStableSwap2Pool(stableSwapPool).add_liquidity(amounts, _estimate);      \n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n\n}\n"
    },
    "contracts/v3/strategies/ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '../interfaces/IConvexVault.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\nimport '../interfaces/ExtendedIERC20.sol';\n\ncontract ConvexStrategy is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        uint256 _pid,\n        IConvexVault _convexVault,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [0]=Sushiswap, [1]=Uniswap\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwap3Pool = _stableSwap3Pool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n        // Required to overcome \"Stack Too Deep\" error\n        _setApprovals(\n            _want,\n            _crvethPool,\n            _cvxethPool,\n            _dai,\n            _usdc,\n            _usdt,\n            address(_convexVault),\n            address(_stableSwap3Pool)\n        );\n    }\n\n    function _setApprovals(\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        address _convexVault,\n        address _stableSwap3Pool\n    ) internal {\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, 0);\n        IERC20(ICurvePool(_crvethPool).coins(1)).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, 0);\n        IERC20(ICurvePool(_cvxethPool).coins(1)).safeApprove(_cvxethPool, type(uint256).max);\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) internal {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, _estimate);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = stableSwap3Pool.balances(0); // DAI\n        balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC\n        balances[2] = stableSwap3Pool.balances(2).mul(10**12); // USDT\n\n        if (balances[0] < balances[1] && balances[0] < balances[2]) {\n            // DAI\n            return (dai, 0);\n        }\n\n        if (balances[1] < balances[0] && balances[1] < balances[2]) {\n            // USDC\n            return (usdc, 1);\n        }\n\n        if (balances[2] < balances[0] && balances[2] < balances[1]) {\n            // USDT\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            (address _stableCoin, ) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        convexVault.withdrawAll(pid);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        convexVault.withdraw(pid, _amount);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/strategies/BTCConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPoolBTC.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport './BaseStrategy.sol';\nimport '../interfaces/ICVXMinter.sol';\nimport '../interfaces/IHarvester.sol';\ncontract BTCConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable crvethPool;\n    address public immutable cvxethPool;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n\n    address[] public tokens;\n    address public premiumToken;\n    uint8[] public decimalMultiples;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crvethPool The address of crvEthPool\n     * @param _cvxethPool The address of cvxEthPool\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _coinCount The number of coins in the pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _premiumTokenIndex The index of the premium asset in the liquidity pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _routerArray The addresses of routers for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crvethPool,\n        address _cvxethPool,\n        address _weth,\n        uint256 _pid,\n        uint256 _coinCount,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        uint256 _premiumTokenIndex,\n        address _controller,\n        address _manager,\n        address[] memory _routerArray // [1] should be set to Uniswap router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _routerArray) {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, , , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = ICurvePool(_crvethPool).coins(1);\n        cvx = ICurvePool(_cvxethPool).coins(1);\n        pid = _pid;\n        convexVault = _convexVault;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n        crvethPool = _crvethPool;\n        cvxethPool = _cvxethPool;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IStableSwapPoolBTC(_stableSwapPool).coins(int128(i)));\n            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());\n            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);\n        }\n        premiumToken = IStableSwapPoolBTC(_stableSwapPool).coins(int128(_premiumTokenIndex));\n\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n        _setApprovals(ICurvePool(_cvxethPool).coins(1), ICurvePool(_crvethPool).coins(1), _crvethPool, _cvxethPool, _routerArray, _crvRewards);\n    }\n\n    function _setApprovals(\n    \taddress _cvx,\n    \taddress _crv,\n        address _crvethPool,\n        address _cvxethPool,\n    \taddress[] memory _routerArray,\n    \taddress _crvRewards\n    ) internal {\n        IERC20(_crv).safeApprove(_crvethPool, 0);\n        IERC20(_crv).safeApprove(_crvethPool, type(uint256).max);\n        IERC20(_cvx).safeApprove(_cvxethPool, 0);\n        IERC20(_cvx).safeApprove(_cvxethPool, type(uint256).max);\n    \tuint _routerArrayLength = _routerArray.length;\n\t    uint rewardsLength = IConvexRewards(_crvRewards).extraRewardsLength();\n        for(uint i=0; i<_routerArrayLength; i++) {\n            address _router = _routerArray[i];\n            if (rewardsLength > 0) {\n            \tfor(uint j=0; j<rewardsLength; j++) {\n                    IERC20(IConvexRewards(IConvexRewards(_crvRewards).extraRewards(j)).rewardToken()).safeApprove(_router, type(uint256).max);\n            \t}\n            }\t\n    \t}\n    }\n    \n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity(uint256 _estimate) internal {\n        if (tokens.length == 2) {\n            uint256[2] memory amounts;\n            amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n            amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n            IStableSwap2Pool(stableSwapPool).add_liquidity(amounts, _estimate);\n            return;\n        }\n\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n        amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n        amounts[2] = IERC20(tokens[2]).balanceOf(address(this));\n        IStableSwap3Pool(stableSwapPool).add_liquidity(amounts, _estimate);\n    }\n\n    function _harvest(uint256[] calldata _estimates) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokensCurve(cvxethPool, 1, 0, _cvxBalance, 1);\n        }\n\n        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();\n        for (uint256 i = 0; i < _extraRewardsLength; i++) {\n            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();\n            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));\n            if (_extraRewardBalance > 0) {\n                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);\n            }\n        }\n\n        uint256 _crvBalance = IERC20(crv).balanceOf(address(this));\n        if (_crvBalance > 0) {\n            _swapTokensCurve(crvethPool, 1, 0, _crvBalance, 1);\n        }\n        uint256 _remainingWeth = _payHarvestFees();\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, premiumToken, _remainingWeth, 1);\n            _addLiquidity(_estimates[0]);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        crvRewards.withdrawAllAndUnwrap(false);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        crvRewards.withdrawAndUnwrap(_amount, false);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(address(crvRewards)).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/interfaces/IStableSwapPoolBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwapPoolBTC {\n    function coins(int128) external view returns (address);\n    function get_virtual_price() external view returns (uint);\n}\n"
    },
    "contracts/v3/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ninterface IVotingEscrow {\n    function balanceOfAt(address _address, uint _block) external view returns (uint);\n    function totalSupplyAt(uint _block) external view returns (uint);\n}\n\n/**\n * @title FeeDistributor\n * @notice Contract shouldn't have added rewards more than tx limit can handle because claiming rewards loops on added rewards\n */\ncontract FeeDistributor {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct Reward {\n        address token;\n        uint blockNumber;\n        uint amount; \n    }\n\n    mapping(address => bool) public isManager;\n    mapping(uint => Reward) public rewards;\n    //index of reward that is next to be claimed\n    mapping(address => uint) public lastClaimed;\n    mapping(address => mapping(uint => bool)) public isClaimed;\n\n    uint public numberOfRewards;\n    IVotingEscrow public votingEscrow;\n\n    constructor(address _votingEscrow) public {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        isManager[msg.sender] = true;\n    }\n\n    /** \n     * @notice Adds a new reward distribution\n     * @param _token The address of the token\n     * @param _amount The amount of token\n     */\n    function addReward(\n        address _token,\n        uint _amount\n    )\n        external\n        onlyManager\n    {\n        Reward memory newReward;\n        newReward.blockNumber = block.number;\n        newReward.token = _token;\n        newReward.amount = _amount;\n\n        rewards[numberOfRewards] = newReward;\n        numberOfRewards++;\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);    \n    }\n\n    /** \n     * @notice Adds a new reward distribution at a specific block\n     * @param _token The address of the token\n     * @param _amount The amount of token\n     * @param _block Block number\n     */\n    function addRewardAtBlock(\n        address _token,\n        uint _amount,\n        uint _block\n    )\n        external\n        onlyManager\n    {\n        Reward memory newReward;\n        newReward.blockNumber = _block;\n        newReward.token = _token;\n        newReward.amount = _amount;\n\n        rewards[numberOfRewards] = newReward;\n        numberOfRewards++;\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);    \n    }\n\n    /** \n     * @notice Returns reward amount of _address in _token\n     * @param _token The address of the token\n     * @param _address The address\n     */\n    function getRewardAmount(\n        address _token,\n        address _address\n    )\n        external\n        view\n        returns(uint reward)\n    {\n        uint addressLastClaimed = lastClaimed[_address];\n        \n        while(addressLastClaimed < numberOfRewards) {\n            Reward memory cReward = rewards[addressLastClaimed];\n\n            //skip if reward is in a different token or if _address already claimed this reward individually\n            if(cReward.token != _token || isClaimed[_address][addressLastClaimed]) {\n                addressLastClaimed++;\n                continue;\n            }\n            \n            //_address share of total supply of veYAXIS at _block times reward amount\n            reward += votingEscrow.balanceOfAt(_address, cReward.blockNumber).mul(cReward.amount).div(votingEscrow.totalSupplyAt(cReward.blockNumber));\n            addressLastClaimed++;\n        } \n    }\n\n    /** \n     * @notice Claims rewards in _token\n     * @param _token The address of the token\n     */\n    function claimRewards(\n        address _token\n    )\n        external\n    {\n        uint addressLastClaimed = lastClaimed[msg.sender];\n        require(addressLastClaimed < numberOfRewards, \"No rewards to claim\");\n\n        uint reward;\n        while(addressLastClaimed < numberOfRewards) {\n            Reward memory cReward = rewards[addressLastClaimed];\n            \n            //skip if sender already claimed this reward individually\n            if(cReward.token != _token || isClaimed[msg.sender][addressLastClaimed]) {\n                addressLastClaimed++;\n                continue;\n            }\n            \n            //sender share of total supply of veYAXIS at _block times reward amount\n            reward += votingEscrow.balanceOfAt(msg.sender, cReward.blockNumber).mul(cReward.amount).div(votingEscrow.totalSupplyAt(cReward.blockNumber));\n            isClaimed[msg.sender][addressLastClaimed] = true;\n            addressLastClaimed++;\n        } \n        //to avoid wasting gas on claiming zero tokens \n        require(reward > 0, \"!rewards\");\n\n        IERC20(_token).safeTransfer(msg.sender, reward);\n        updateLastClaimed(msg.sender);\n    }\n\n    /** \n     * @notice Claims reward by index in _token\n     * @param _token The address of the token\n     * @param _index The index of the reward\n     */\n    function claimRewardsByIndex(\n        address _token,\n        uint _index\n    )\n        external\n    {\n        require(_index < numberOfRewards, \"Wrong index\");\n        require(!isClaimed[msg.sender][_index], \"Reward is already claimed\");\n\n        Reward memory cReward = rewards[_index];\n\n        uint reward = votingEscrow.balanceOfAt(msg.sender, cReward.blockNumber).mul(cReward.amount).div(votingEscrow.totalSupplyAt(cReward.blockNumber));\n        isClaimed[msg.sender][_index] = true;\n        \n        //to avoid wasting gas on claiming zero tokens\n        require(reward > 0, \"!rewards\");\n\n        IERC20(_token).safeTransfer(msg.sender, reward);\n        updateLastClaimed(msg.sender);\n    }\n\n    /**\n     * @notice Updates lastClaimed that is used to reduce loops\n     * @param _address The address to optimize\n     */\n    function updateLastClaimed(\n        address _address\n    )\n        internal\n    {\n        uint addressLastClaimed = lastClaimed[_address];\n\n        while(addressLastClaimed < numberOfRewards) {\n            if(!isClaimed[_address][addressLastClaimed]) {\n                lastClaimed[_address] = addressLastClaimed;\n                break;\n            }\n            addressLastClaimed++;\n        }\n    }\n\n    /**\n     * @notice Sets the status of a manager\n     * @param _manager The address of the manager\n     * @param _status The status to allow the manager \n     */\n    function setManager(\n        address _manager,\n        bool _status\n    )\n        external\n        onlyManager\n    {\n        isManager[_manager] = _status;\n    }\n\n    modifier onlyManager() {\n        require(isManager[msg.sender], \"!manager\");\n        _;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}